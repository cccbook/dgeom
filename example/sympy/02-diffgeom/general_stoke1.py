"""
廣義斯托克斯定理 (Generalized Stokes' Theorem) 驗證
∫_M dω = ∫_∂M ω
展示各種特殊情況並數值驗證
"""

from sympy import symbols, sin, cos, sqrt, simplify, pi, Symbol, integrate, atan2
from sympy import Matrix, diff
import numpy as np

print("=" * 70)
print("廣義斯托克斯定理 (Generalized Stokes' Theorem)")
print("∫_M dω = ∫_∂M ω")
print("=" * 70)

print("\n定理陳述:")
print("對於 n 維流形 M 及其 (n-1) 維邊界 ∂M,")
print("以及 (n-1)-形式 ω,有:")
print("\n    ∫_M dω = ∫_∂M ω")
print("\n這統一了微積分中的所有積分定理!")

print("\n" + "=" * 70)
print("1. 微積分基本定理 (1維情況)")
print("=" * 70)

print("\n∫_a^b f'(x) dx = f(b) - f(a)")

# 定義函數
x = Symbol('x', real=True)
f = x**3 + 2*x**2 + 1
f_prime = diff(f, x)

a_val, b_val = 0, 2

print(f"\n函數: f(x) = {f}")
print(f"導數: f'(x) = {f_prime}")
print(f"區間: [{a_val}, {b_val}]")

# 左側: 積分 f'(x)
left_side = integrate(f_prime, (x, a_val, b_val))
print(f"\n左側 ∫_0^2 f'(x) dx = {left_side}")

# 右側: 邊界值
right_side = f.subs(x, b_val) - f.subs(x, a_val)
print(f"右側 f(2) - f(0) = {right_side}")

print(f"\n驗證: {left_side} = {right_side} ✓")

print("\n斯托克斯定理解釋:")
print("• M = [a,b] (1維區間)")
print("• ∂M = {b, -a} (邊界點,帶符號)")
print("• ω = f (0-形式)")
print("• dω = f'dx (1-形式)")
print("• ∫_∂M ω = f(b) - f(a)")

print("\n" + "=" * 70)
print("2. 格林定理 (2維情況)")
print("=" * 70)

print("\n∫∫_D (∂Q/∂x - ∂P/∂y) dA = ∮_∂D P dx + Q dy")

# 定義座標
x_var = Symbol('x', real=True)
y_var = Symbol('y', real=True)

# 定義向量場 F = (P, Q)
P = -y_var
Q = x_var

print(f"\n向量場: F = (P, Q) = ({P}, {Q})")
print(f"1-形式: ω = P dx + Q dy = {P} dx + {Q} dy")

# 計算旋度
dQ_dx = diff(Q, x_var)
dP_dy = diff(P, y_var)
curl = dQ_dx - dP_dy

print(f"\n旋度(外微分):")
print(f"∂Q/∂x = {dQ_dx}")
print(f"∂P/∂y = {dP_dy}")
print(f"∂Q/∂x - ∂P/∂y = {curl}")

print(f"\n外微分: dω = {curl} dx∧dy")

# 在單位圓上驗證
print("\n在單位圓盤 D = {x²+y² ≤ 1} 上驗證:")

# 左側: 面積分
# ∫∫_D 2 dA = 2 × π × 1² = 2π
left_side = curl * pi  # 單位圓面積是 π
print(f"\n左側 ∫∫_D {curl} dA = {curl} × π = {left_side}")

# 右側: 線積分 (參數化圓周)
# x = cos(t), y = sin(t), t ∈ [0, 2π]
# ω = -y dx + x dy = -sin(t)(-sin(t) dt) + cos(t)(cos(t) dt)
#   = sin²(t) dt + cos²(t) dt = dt
print("\n右側邊界積分:")
print("圓周參數化: x = cos(t), y = sin(t), t ∈ [0, 2π]")
print("ω = -y dx + x dy")
print("  = -sin(t)·(-sin(t) dt) + cos(t)·(cos(t) dt)")
print("  = sin²(t) dt + cos²(t) dt")
print("  = dt")

t = Symbol('t', real=True)
integrand = 1  # dt 的係數
right_side = integrate(integrand, (t, 0, 2*pi))
print(f"\n∮_∂D ω = ∫_0^{2*pi} dt = {right_side}")

print(f"\n驗證: {left_side} = {right_side} ✓")

print("\n斯托克斯定理解釋:")
print("• M = D (2維圓盤)")
print("• ∂M = S¹ (1維圓周)")
print("• ω = P dx + Q dy (1-形式)")
print("• dω = (∂Q/∂x - ∂P/∂y) dx∧dy (2-形式)")

print("\n" + "=" * 70)
print("3. 散度定理 (3維情況)")
print("=" * 70)

print("\n∫∫∫_V (∇·F) dV = ∮∮_∂V F·n̂ dS")

# 定義座標
z_var = Symbol('z', real=True)

# 定義向量場 F = (x, y, z)
F1 = x_var
F2 = y_var
F3 = z_var

print(f"\n向量場: F = ({F1}, {F2}, {F3})")

# 計算散度
div_F = diff(F1, x_var) + diff(F2, y_var) + diff(F3, z_var)
print(f"\n散度: ∇·F = ∂F₁/∂x + ∂F₂/∂y + ∂F₃/∂z = {div_F}")

# 在單位球上驗證
print("\n在單位球 V = {x²+y²+z² ≤ 1} 上驗證:")

# 左側: 體積分
# ∫∫∫_V 3 dV = 3 × (4π/3) × 1³ = 4π
volume_sphere = 4*pi/3
left_side = div_F * volume_sphere
print(f"\n左側 ∫∫∫_V {div_F} dV = {div_F} × (4π/3) = {left_side}")

# 右側: 面積分
# 在球面上 F·n̂ = (x,y,z)·(x,y,z) = x²+y²+z² = 1 (單位球)
print("\n右側面積分:")
print("在單位球面上: n̂ = (x,y,z) (外法向量)")
print("F·n̂ = x² + y² + z² = 1")
surface_area = 4*pi
right_side = 1 * surface_area
print(f"∮∮_∂V F·n̂ dS = 1 × 4π = {right_side}")

print(f"\n驗證: {left_side} = {right_side} ✓")

print("\n斯托克斯定理解釋:")
print("• M = V (3維球)")
print("• ∂M = S² (2維球面)")
print("• ω = F₁ dy∧dz + F₂ dz∧dx + F₃ dx∧dy (2-形式)")
print("• dω = (∇·F) dx∧dy∧dz (3-形式)")

print("\n" + "=" * 70)
print("4. 旋度定理 (3維曲面)")
print("=" * 70)

print("\n∫∫_S (∇×F)·n̂ dS = ∮_∂S F·dr")

# 定義向量場
F1_curl = -y_var
F2_curl = x_var
F3_curl = 0

print(f"\n向量場: F = ({F1_curl}, {F2_curl}, {F3_curl})")

# 計算旋度
curl_x = diff(F3_curl, y_var) - diff(F2_curl, z_var)
curl_y = diff(F1_curl, z_var) - diff(F3_curl, x_var)
curl_z = diff(F2_curl, x_var) - diff(F1_curl, y_var)

print(f"\n旋度: ∇×F = ({curl_x}, {curl_y}, {curl_z})")

# 在單位圓盤(z=0平面)上驗證
print("\n在圓盤 S = {x²+y² ≤ 1, z=0} 上驗證:")
print("法向量: n̂ = (0, 0, 1)")

# 左側: 面積分
# (∇×F)·n̂ = curl_z = 2
left_side = curl_z * pi  # 圓盤面積是 π
print(f"\n左側 ∫∫_S (∇×F)·n̂ dS = {curl_z} × π = {left_side}")

# 右側: 線積分(與格林定理相同)
print("\n右側線積分:")
print("∮_∂S F·dr = ∮ (-y dx + x dy) = 2π (如前所示)")
right_side = 2*pi

print(f"\n驗證: {left_side} = {right_side} ✓")

print("\n斯托克斯定理解釋:")
print("• M = S (2維曲面)")
print("• ∂M = C (1維曲線)")
print("• ω = F·dr (1-形式)")
print("• dω 對應 (∇×F)·n̂ dS (2-形式)")

print("\n" + "=" * 70)
print("5. 數值驗證 - 任意三角形上的格林定理")
print("=" * 70)

print("\n用數值方法驗證三角形區域:")

# 定義三角形頂點
vertices = np.array([
    [0.0, 0.0],
    [1.0, 0.0],
    [0.5, 0.8]
])

print(f"\n三角形頂點:")
for i, v in enumerate(vertices):
    print(f"  P{i} = {v}")

# 向量場 F = (-y, x)
def P_func(x, y):
    return -y

def Q_func(x, y):
    return x

# 旋度
def curl_func(x, y):
    return 2.0  # ∂Q/∂x - ∂P/∂y = 1 - (-1) = 2

# 計算面積分(使用簡單的數值方法)
# 三角形面積
area = 0.5 * abs(
    vertices[0,0]*(vertices[1,1] - vertices[2,1]) +
    vertices[1,0]*(vertices[2,1] - vertices[0,1]) +
    vertices[2,0]*(vertices[0,1] - vertices[1,1])
)
print(f"\n三角形面積: {area:.4f}")

# 面積分
surface_integral = curl_func(0, 0) * area
print(f"面積分 ∫∫_D (∂Q/∂x - ∂P/∂y) dA = {curl_func(0,0)} × {area:.4f} = {surface_integral:.4f}")

# 計算線積分(沿三條邊)
def line_integral_segment(p1, p2, P_func, Q_func, n_points=1000):
    """計算一條線段上的線積分"""
    t = np.linspace(0, 1, n_points)
    x = p1[0] + t * (p2[0] - p1[0])
    y = p1[1] + t * (p2[1] - p1[1])
    
    dx = (p2[0] - p1[0]) / n_points
    dy = (p2[1] - p1[1]) / n_points
    
    integral = 0.0
    for i in range(len(t)):
        integral += P_func(x[i], y[i]) * dx + Q_func(x[i], y[i]) * dy
    
    return integral

print("\n線積分(逐邊計算):")
line_integral_total = 0.0

for i in range(3):
    p1 = vertices[i]
    p2 = vertices[(i+1) % 3]
    segment_integral = line_integral_segment(p1, p2, P_func, Q_func)
    print(f"  邊 {i}: P{i} → P{(i+1)%3}: {segment_integral:.4f}")
    line_integral_total += segment_integral

print(f"\n線積分總和 ∮_∂D P dx + Q dy = {line_integral_total:.4f}")

# 驗證
error = abs(surface_integral - line_integral_total)
print(f"\n驗證:")
print(f"  面積分: {surface_integral:.4f}")
print(f"  線積分: {line_integral_total:.4f}")
print(f"  誤差: {error:.6f}")

if error < 0.01:
    print("  ✓ 斯托克斯定理驗證成功!")
else:
    print("  ✗ 數值誤差較大")

print("\n" + "=" * 70)
print("6. 數值驗證 - 圓柱面上的旋度定理")
print("=" * 70)

print("\n考慮半徑為 1,高度為 1 的圓柱側面")
print("向量場: F = (0, 0, x²+y²)")

def F_cylinder(x, y, z):
    """圓柱上的向量場"""
    return np.array([0, 0, x**2 + y**2])

def curl_F_cylinder(x, y, z):
    """旋度: ∇×F = (2y, -2x, 0)"""
    return np.array([2*y, -2*x, 0])

# 圓柱側面參數化: x=cos(θ), y=sin(θ), z=z, θ∈[0,2π], z∈[0,1]
n_theta = 50
n_z = 30

print(f"\n數值網格: {n_theta} × {n_z}")

# 面積分
surface_integral_cylinder = 0.0
dtheta = 2*np.pi / n_theta
dz = 1.0 / n_z

for i in range(n_theta):
    for j in range(n_z):
        theta = i * dtheta
        z = j * dz
        
        x = np.cos(theta)
        y = np.sin(theta)
        
        # 法向量(向外): n̂ = (cos(θ), sin(θ), 0)
        n = np.array([np.cos(theta), np.sin(theta), 0])
        
        # 旋度
        curl = curl_F_cylinder(x, y, z)
        
        # (∇×F)·n̂
        integrand = np.dot(curl, n)
        
        # 面積元素: dS = r dθ dz = 1 × dθ × dz
        surface_integral_cylinder += integrand * dtheta * dz

print(f"\n面積分 ∫∫_S (∇×F)·n̂ dS = {surface_integral_cylinder:.4f}")

# 線積分(沿頂部和底部圓周)
line_integral_cylinder = 0.0

# 底圓 (z=0)
print("\n線積分:")
for i in range(n_theta):
    theta1 = i * dtheta
    theta2 = (i+1) * dtheta
    
    x1, y1 = np.cos(theta1), np.sin(theta1)
    x2, y2 = np.cos(theta2), np.sin(theta2)
    
    # F = (0, 0, x²+y²) = (0, 0, 1) 在單位圓上
    # dr = (-sin(θ)dθ, cos(θ)dθ, 0)
    # F·dr = 0
    # 底圓貢獻為 0

# 頂圓 (z=1)
# 同樣 F·dr = 0
# 總線積分為 0

print("  底圓 (z=0): F·dr = 0")
print("  頂圓 (z=1): F·dr = 0")
print(f"  總線積分: {line_integral_cylinder:.4f}")

error_cylinder = abs(surface_integral_cylinder - line_integral_cylinder)
print(f"\n驗證:")
print(f"  面積分: {surface_integral_cylinder:.4f}")
print(f"  線積分: {line_integral_cylinder:.4f}")
print(f"  誤差: {error_cylinder:.6f}")

if error_cylinder < 0.1:
    print("  ✓ 斯托克斯定理驗證成功!")

print("\n" + "=" * 70)
print("7. 理論總結")
print("=" * 70)

print("\n廣義斯托克斯定理統一了:")
print("┌─────────────────┬──────────────────┬─────────────────┐")
print("│  維度  │      定理名稱    │   公式形式      │")
print("├─────────────────┼──────────────────┼─────────────────┤")
print("│  1D    │  微積分基本定理  │ ∫f'dx = f(b)-f(a)│")
print("│  2D    │  格林定理        │ ∫∫curl dA = ∮ω  │")
print("│  3D    │  散度定理        │ ∫∫∫div dV = ∮∮ω │")
print("│  3D    │  旋度定理        │ ∫∫curl·n̂ dS = ∮ω│")
print("│  nD    │  斯托克斯定理    │ ∫dω = ∫ω        │")
print("└─────────────────┴──────────────────┴─────────────────┘")

print("\n關鍵洞察:")
print("• 「積分的導數 = 邊界上的值」")
print("• 整體性質由邊界決定")
print("• 微分形式提供統一語言")
print("• 拓撲與幾何的深刻聯繫")

print("\n應用領域:")
print("✓ 電磁學 (Maxwell 方程)")
print("✓ 流體力學 (Navier-Stokes)")
print("✓ 廣義相對論 (Einstein 場方程)")
print("✓ 拓撲學 (de Rham 上同調)")
print("✓ 複分析 (Cauchy 積分定理)")
print("✓ 微分幾何 (Gauss-Bonnet 定理)")

print("\n" + "=" * 70)
print("示範完成!")
print("=" * 70)

print("\n歷史:")
print("• 1823: Green (格林定理)")
print("• 1828: Gauss (散度定理)")
print("• 1854: Stokes (旋度定理)")
print("• 1945: de Rham (統一理論)")
print("• 現代: 微分形式成為標準語言")