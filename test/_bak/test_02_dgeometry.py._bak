import pytest
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
from dgeom.sym import *

# ===================================================================
# æ¸¬è©¦ 1: å‘é‡å¾®ç©åˆ† (Vector Calculus)
# ===================================================================

def test_calculus_curl_of_gradient_euclidean():
    """
    ### ğŸ§ª é©—è­‰ï¼šæ¢¯åº¦çš„æ—‹åº¦ç‚ºé›¶ (Euclidean)
    æ•¸å­¸å…¬å¼: âˆ‡ Ã— (âˆ‡f) = 0
    """
    # 1. å–å¾—æ–°ç‰ˆ MetricTensor
    tm = euclidean_metric()
    x, y, z = tm.coords 

    # 2. å®šç¾©ç´”é‡å ´ f
    f = x**2 * y * sp.cos(z)
    
    # 3. è¨ˆç®—æ¢¯åº¦ (Gradient) -> å›å‚³ Covariant Vector [-1]
    grad_f = d_gradient(f, tm)
    
    # é©—è­‰æ¢¯åº¦é¡å‹
    assert isinstance(grad_f, GeometricTensor)
    assert grad_f.index_config == [-1]
    
    # 4. è¨ˆç®—æ—‹åº¦ (Curl) -> å›å‚³ Covariant Vector [-1] (è¦–å¯¦ä½œè€Œå®š)
    # ç”±æ–¼ d_curl å…§éƒ¨æœƒè™•ç†æŒ‡æ¨™å‡é™ï¼Œæˆ‘å€‘ç›´æ¥å‚³å…¥
    curl_grad_f = d_curl(grad_f, tm) 

    # 5. é©—è­‰çµæœç‚ºé›¶å¼µé‡
    # å±•é–‹ NDimArray æª¢æŸ¥æ¯å€‹åˆ†é‡
    for val in np.array(curl_grad_f.data).flatten():
        assert sp.simplify(val) == 0, f"åˆ†é‡ {val} æ‡‰ç‚º 0"


def test_calculus_curl_of_gradient_spherical():
    """
    ### ğŸ§ª é©—è­‰ï¼šçƒåæ¨™ä¸‹çš„æ¢¯åº¦æ—‹åº¦ç‚ºé›¶
    é€™é©—è­‰äº†æ–°ç‰ˆ d_curl æ˜¯å¦æ­£ç¢ºè™•ç†äº† sqrt(g) å’Œ Levi-Civita ç¬¦è™Ÿ
    """
    # 1. å–å¾—çƒåæ¨™åº¦è¦
    tm = spherical_metric()
    r, theta, phi = tm.coords

    # 2. å®šç¾©ç´”é‡å ´ f
    f = r**2 * sp.cos(theta) * sp.sin(phi)

    # 3. è¨ˆç®—
    grad_f = d_gradient(f, tm) 
    curl_grad_f = d_curl(grad_f, tm) 

    # 4. é©—è­‰
    for val in np.array(curl_grad_f.data).flatten():
        assert sp.simplify(val) == 0, f"çƒåæ¨™ä¸‹ Curl(Grad) åˆ†é‡ {val} æ‡‰ç‚º 0"


# ===================================================================
# æ¸¬è©¦ 2: å¤–å¾®åˆ† (Exterior Derivative)
# ===================================================================

def testexterior_derivative_squared_is_zero():
    """
    ### ğŸ§ª é©—è­‰ï¼šå¤–å¾®åˆ†çš„å¹³æ–¹ç‚ºé›¶ d(d(omega)) = 0
    ä¾è³´ TangentVector å’Œ Form çš„æ–°å¯¦ä½œ
    """
    tm = euclidean_metric()
    x, y, z = tm.coords
    
    # 0-form (ç´”é‡å ´)
    f = x*y*z
    omega_0 = Form(0, f) 
    
    # d(f) -> 1-form
    d_omega_0 = d_operator(omega_0)  
    
    # d(d(f)) -> 2-form
    dd_omega_0 = d_operator(d_omega_0) 
    
    # é©—è­‰ç®—å­ä½œç”¨åœ¨ä»»æ„å‘é‡å ´ä¸Šæ˜¯å¦ç‚º 0
    # éš¨æ©Ÿå®šç¾©å…©å€‹åˆ‡å‘é‡
    v1 = TangentVector([1, 0, 0], tm.coords)
    v2 = TangentVector([0, 1, z], tm.coords)
    
    # 2-form ä½œç”¨åœ¨å…©å€‹å‘é‡ä¸Šæ‡‰å›å‚³ç´”é‡
    result = dd_omega_0(v1, v2)
    
    assert sp.simplify(result) == 0


# ===================================================================
# æ¸¬è©¦ 3: æŒ‡æ¨™å‡é™ (Musical Isomorphisms)
# ===================================================================

def test_tensor_index_raising_lowering():
    """
    ### ğŸ§ª é©—è­‰ï¼šæŒ‡æ¨™å‡é™ (å–ä»£èˆŠç‰ˆ HodgeMetric.flat/sharp)
    Flat (é™æŒ‡æ¨™): v_i = g_ij v^j
    Sharp (å‡æŒ‡æ¨™): v^i = g^ij v_j
    """
    # 1. æº–å‚™åº¦è¦
    tm = euclidean_metric()
    x, y, z = tm.coords
    
    # 2. å»ºç«‹é€†è®Šå‘é‡ V (Contravariant, Rank 1, [+1])
    # V = x^2 âˆ‚x + y âˆ‚y + cos(z) âˆ‚z
    # æ³¨æ„: TangentVector ç¹¼æ‰¿ GeometricTensorï¼Œé è¨­ç‚º [1]
    V = TangentVector([x**2, y, sp.cos(z)], tm.coords, name='V')
    
    assert V.index_config == [1]
    
    # 3. åŸ·è¡Œé™æŒ‡æ¨™ (Flat): g_ij V^j -> V_i
    # Tensor Product: g[-1,-1] * V[1] -> Rank 3 [-1,-1,1]
    # Contract: index 1 (g_col) with index 2 (V)
    # çµæœ: [-1] (V_i)
    mixed = tm.tensor_product(V)
    V_flat = mixed.contract(1, 2)
    
    assert V_flat.index_config == [-1]
    
    # 4. åŸ·è¡Œå‡æŒ‡æ¨™ (Sharp): g^ik V_k -> V^i
    # éœ€è¦é€†åº¦è¦ g^ik
    g_inv = tm.inverse() # [1, 1]
    
    # Tensor Product: g^[1,1] * V_flat[-1] -> Rank 3 [1,1,-1]
    # Contract: index 1 (g_inv_col) with index 2 (V_flat)
    # çµæœ: [1] (V^i)
    mixed_up = g_inv.tensor_product(V_flat)
    V_sharp = mixed_up.contract(1, 2)
    
    assert V_sharp.index_config == [1]
    
    # 5. é©—è­‰ V_sharp == V (é€†é‹ç®—æˆç«‹)
    # æ¯”è¼ƒ data (NDimArray)
    diff_data = V_sharp.data - V.data
    for val in np.array(diff_data).flatten():
        assert sp.simplify(val) == 0

# ===================================================================
# æ¸¬è©¦ 4: æ¸¬åœ°ç·š (Geodesic)
# ===================================================================

def test_geodesic_equations_symbolic():
    """
    é©—è­‰ MetricTensor èƒ½æ­£ç¢ºç”Ÿæˆæ¸¬åœ°ç·šå¾®åˆ†æ–¹ç¨‹ (ç¬¦è™Ÿ)ã€‚
    ä½¿ç”¨ 2D çƒé¢ (r=1) ç‚ºä¾‹ã€‚
    """
    # 1. æ‰‹å‹•å»ºç«‹ 2D çƒé¢ MetricTensor
    theta, phi = sp.symbols('theta phi', real=True)
    coords = [theta, phi]
    # ds^2 = dtheta^2 + sin^2(theta) dphi^2
    g_data = sp.diag(1, sp.sin(theta)**2)
    
    tm = MetricTensor(g_data, coords)
    
    # 2. ç”Ÿæˆæ–¹ç¨‹å¼
    tau = sp.Symbol('tau')
    eqs = tm.get_geodesic_equations(param_var=tau)
    
    # 3. é©—è­‰ theta æ–¹ç¨‹: theta'' - sin(theta)cos(theta) * (phi')^2 = 0
    # MetricTensor å›å‚³å½¢å¼: Eq(theta'', RHS) => theta'' = RHS
    theta_func = sp.Function('theta')(tau)
    phi_func = sp.Function('phi')(tau)
    
    theta_rhs = eqs[0].rhs
    
    # é æœŸ RHS = sin(theta)*cos(theta) * (phi')^2
    # æ³¨æ„: christoffel symbol ç®—å‡ºä¾† Gamma^theta_phi,phi = -sin cos
    # geodesic eq: theta'' + (-sin cos) phi' phi' = 0
    # theta'' = sin cos (phi')^2
    expected_rhs = sp.sin(theta_func) * sp.cos(theta_func) * sp.diff(phi_func, tau)**2
    
    assert sp.simplify(theta_rhs - expected_rhs) == 0

@pytest.mark.skipif(not pytest.importorskip("scipy"), reason="éœ€è¦ scipy")
def test_geodesic_bvp_numerical():
    """
    æ•¸å€¼é©—è­‰ï¼šçƒé¢ä¸Šçš„æ¸¬åœ°ç·š (å¤§åœ“)ã€‚
    å¾åŒ—æ¥µé™„è¿‘èµ°åˆ°èµ¤é“ï¼Œè·¯å¾‘æ‡‰æ²¿è‘—ç¶“ç·šã€‚
    """
    # 1. å»ºç«‹ 2D çƒé¢ MetricTensor
    theta, phi = sp.symbols('theta phi', real=True)
    coords = [theta, phi]
    g_data = sp.diag(1, sp.sin(theta)**2)
    tm = MetricTensor(g_data, coords)
    
    # 2. è¨­å®šé‚Šç•Œæ¢ä»¶ (æ²¿ç¶“ç·š phi=0 èµ°)
    start = [0.1, 0.0]
    end = [np.pi/2, 0.0]
    
    # 3. æ±‚è§£
    path = tm.solve_geodesic_bvp(start, end, num_points=21)
    
    thetas = path[0]
    phis = path[1]
    
    # 4. é©—è­‰
    # A. phi æ‡‰è©²ä¿æŒæ†å®š (ç´„ç‚º 0)
    assert np.allclose(phis, 0.0, atol=1e-4), "ç¶“ç·šæ¸¬åœ°ç·šçš„ phi æ‡‰ä¿æŒä¸è®Š"
    
    # B. theta æ‡‰è©²ç·šæ€§å¢åŠ  (å¢é‡ä¸€è‡´)
    theta_diffs = np.diff(thetas)
    assert np.std(theta_diffs) < 1e-4, "theta æ‡‰ç·šæ€§è®ŠåŒ–"


# ===================================================================
# è¦–è¦ºåŒ–æ¼”ç¤º (æ‰‹å‹•åŸ·è¡Œæ™‚é¡¯ç¤º)
# ===================================================================

if __name__ == "__main__":
    print("æ­£åœ¨åŸ·è¡Œçƒé¢æ¸¬åœ°ç·šè¦–è¦ºåŒ–...")
    
    # æº–å‚™åº¦è¦
    theta, phi = sp.symbols('theta phi', real=True)
    g_data = sp.diag(1, sp.sin(theta)**2)
    tm = MetricTensor(g_data, [theta, phi])
    
    # è¨­å®šè·¯å¾‘: å¾ (0.2, 0) èµ°åˆ° (pi/2, pi/2) çš„æ–œå‘å¤§åœ“
    start = [0.2, 0.0]
    end = [np.pi/2, np.pi/2]
    
    try:
        import scipy
        path = tm.solve_geodesic_bvp(start, end, num_points=50)
        thetas = path[0]
        phis = path[1]

        # è½‰æ›ç‚º 3D ç›´è§’åæ¨™ä»¥ä¾¿ç¹ªåœ–
        X = np.sin(thetas) * np.cos(phis)
        Y = np.sin(thetas) * np.sin(phis)
        Z = np.cos(thetas)

        # ç¹ªåœ–
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        # ç•«çƒç¶²æ ¼
        u, v = np.mgrid[0:2*np.pi:30j, 0:np.pi:15j]
        x_sphere = np.cos(u)*np.sin(v)
        y_sphere = np.sin(u)*np.sin(v)
        z_sphere = np.cos(v)
        ax.plot_wireframe(x_sphere, y_sphere, z_sphere, color="gray", alpha=0.1)
        
        # ç•«è·¯å¾‘
        ax.plot(X, Y, Z, color='r', linewidth=3, label='Geodesic Path')
        ax.scatter([X[0]], [Y[0]], [Z[0]], color='g', s=100, label='Start')
        ax.scatter([X[-1]], [Y[-1]], [Z[-1]], color='b', s=100, label='End')
        
        ax.set_title("Geodesic on MetricTensor Sphere")
        ax.legend()
        plt.show()
        
    except ImportError:
        print("ç¼ºå°‘ numpy/scipy/matplotlibï¼Œç„¡æ³•åŸ·è¡Œè¦–è¦ºåŒ–ã€‚")
    except Exception as e:
        print(f"åŸ·è¡ŒéŒ¯èª¤: {e}")