import sympy as sp
import numpy as np
import pytest
from dgeom.sym import get_euclidean_metric, get_spherical_metric, Metric
from dgeom.sym import HodgeMetric, TangentVector, Form, d_gradient, d_curl, d_operator

# --------------------------------------------------
# æ¸¬è©¦å‡½å¼
# --------------------------------------------------

def test_dvcalculus_curl_of_gradient_is_zero():
    """
    ### ğŸ§ª é©—è­‰ vcalculus.pyï¼šæ¢¯åº¦çš„æ—‹åº¦ç‚ºé›¶
    æ•¸å­¸å…¬å¼: $\nabla \times (\nabla f) = \mathbf{0}$
    """
    # 1. å–å¾—åº¦è¦èˆ‡åæ¨™
    metric_obj = get_euclidean_metric()
    x, y, z = metric_obj.coords  # ã€é—œéµã€‘å¾ç‰©ä»¶è§£åŒ…åæ¨™

    # 2. å®šç¾©ç´”é‡å ´ f (ä½¿ç”¨è§£åŒ…å‡ºä¾†çš„ç¬¦è™Ÿ)
    f = x**2 * y * sp.cos(z)
    
    # [ä¿®æ­£] å°‡ Metric åŒ…è£æˆ HodgeMetric
    # æ³¨æ„ï¼šé€™è£¡å‚³å…¥çš„æ˜¯ Metric ç‰©ä»¶å…§éƒ¨çš„ g å’Œ coords
    h_metric = HodgeMetric(metric_obj.g, metric_obj.coords)
    
    # 3. è¨ˆç®—
    grad_f = d_gradient(f, h_metric)      
    curl_grad_f = d_curl(grad_f, h_metric) 

    assert sp.simplify(curl_grad_f) == sp.zeros(3, 1), \
        r"âˆ‡ Ã— (âˆ‡f) æ‡‰ç‚ºé›¶å‘é‡"


def test_dvcalculus_curl_of_gradient_spherical():
    """
    ### ğŸ§ª é©—è­‰ dvcalculus.pyï¼šçƒåæ¨™ä¸‹çš„ $\nabla \times (\nabla f) = \mathbf{0}$
    """
    # 1. å–å¾—çƒåæ¨™åº¦è¦
    metric_obj = get_spherical_metric()
    r, theta, phi = metric_obj.coords # ã€é—œéµã€‘è§£åŒ…åæ¨™

    # 2. å®šç¾©ç´”é‡å ´ f
    f = r**2 * sp.cos(theta) * sp.sin(phi)

    # å‡è¨­ d_gradient æ”¯æ´ç›´æ¥å‚³å…¥ Metric ç‰©ä»¶ (æˆ–éœ€è¦è½‰ç‚º HodgeMetricï¼Œè¦–æ‚¨å¯¦ä½œè€Œå®š)
    # é€™è£¡ä¾ç…§æ‚¨åŸæœ¬çš„å¯«æ³•ç›´æ¥å‚³å…¥ metric
    grad_f_cov = d_gradient(f, metric_obj) 
    curl_grad_f_cov = d_curl(grad_f_cov, metric_obj) 

    # [æ–°ä¿®æ­£] d_curl å›å‚³çš„æ˜¯ SymPy Matrix
    assert sp.simplify(curl_grad_f_cov) == sp.zeros(3, 1), \
        r"åœ¨çƒåæ¨™ä¸‹ï¼Œd_curl(d_gradient(f)) æ‡‰ç‚ºé›¶å‘é‡"


def test_dvectorexterior_derivative_dd_is_zero():
    """
    ### ğŸ§ª é©—è­‰ dvector.pyï¼šå¤–å¾®åˆ†çš„å¹³æ–¹ç‚ºé›¶
    æ•¸å­¸å…¬å¼: $d(d(\omega)) = 0$
    """
    # ç‚ºäº†å®šç¾©å‡½æ•¸ fï¼Œæˆ‘å€‘éœ€è¦ x, y, z ç¬¦è™Ÿ
    # æœ€ä¹¾æ·¨çš„æ–¹å¼æ˜¯å¾æ­å¹¾é‡Œå¾—åº¦è¦å·¥å» å–å¾—
    metric_obj = get_euclidean_metric()
    x, y, z = metric_obj.coords
    
    f = x*y*z
    omega_0 = Form(0, f) 
    
    d_omega_0 = d_operator(omega_0)  
    dd_omega_0 = d_operator(d_omega_0) 
    
    expected_coeffs = 0 
    
    # å‘¼å« .op() å–å¾—ä¿‚æ•¸çŸ©é™£ (è¦–æ‚¨çš„ Form å¯¦ä½œè€Œå®š)
    # å¦‚æœ Form.op æ˜¯å±¬æ€§è€Œéæ–¹æ³•ï¼Œè«‹æ‹¿æ‰æ‹¬è™Ÿ
    result = dd_omega_0.op() if callable(dd_omega_0.op) else dd_omega_0.op
    
    assert sp.simplify(result) == expected_coeffs, \
        r"å¤–å¾®åˆ†çš„å¹³æ–¹ $d(d(\omega))$ çš„æ‰€æœ‰åˆ†é‡æ‡‰ç‚ºé›¶"


def test_hodge_flat_sharp_inversion():
    """
    ### ğŸ§ª é©—è­‰ hodge.pyï¼šæŒ‡æ¨™å‡é™çš„é€†é‹ç®—
    """
    # 1. æº–å‚™åº¦è¦
    base_metric = get_euclidean_metric()
    x, y, z = base_metric.coords
    
    # å»ºç«‹ HodgeMetric
    metric = HodgeMetric(base_metric.g, base_metric.coords)

    # 2. å»ºç«‹å‘é‡ V
    # ä½¿ç”¨ base_metric.coords ç¢ºä¿åæ¨™ä¸€è‡´
    V = TangentVector(sp.Matrix([x**2, y, sp.cos(z)]), base_metric.coords, name='V') 
    
    # 3. åŸ·è¡Œå‡é™é‹ç®—
    V_flat = metric.flat(V)     
    V_sharp = metric.sharp(V_flat)
    
    V_orig_comps = V.components
    V_sharp_comps = V_sharp.components
    
    assert sp.simplify(V_sharp_comps - V_orig_comps) == sp.zeros(3, 1), \
        r"æŒ‡æ¨™å‡é™é‹ç®—æ‡‰ç‚ºé€†é‹ç®—"

import numpy as np
import matplotlib.pyplot as plt

def test_geodesic():
    # 1. å»ºç«‹çƒåæ¨™åº¦è¦
    metric = get_spherical_metric()
    # åæ¨™: [r, theta, phi]
    # æˆ‘å€‘å›ºå®š r = 1 (å–®ä½çƒ)ï¼Œåªåœ¨ theta, phi ä¸Šç§»å‹•
    # ä½†å› ç‚ºæˆ‘å€‘çš„åº¦è¦æ˜¯ 3D çš„ï¼Œæˆ‘å€‘éœ€è¦çµ¦å‡º 3D åæ¨™ï¼Œä¸¦è®“ r ä¿æŒæ†å®šã€‚
    # å¯¦éš›ä¸Šï¼Œç‚ºäº†è§£å¾—æ¼‚äº®ï¼Œæœ€å¥½ç›´æ¥å»ºç«‹ä¸€å€‹ 2D çƒé¢åº¦è¦ï¼Œæˆ–è€…åœ¨ 3D ä¸­çµ¦å®š r=1 çš„é‚Šç•Œæ¢ä»¶ã€‚
    # ç‚ºäº†ç°¡å–®æ¼”ç¤ºï¼Œæˆ‘å€‘é€™è£¡å»ºç«‹ä¸€å€‹ 2D çƒé¢åº¦è¦ (r=1)

    # --- å»ºç«‹ 2D çƒé¢åº¦è¦ (Unit Sphere) ---
    theta, phi = sp.symbols('theta phi', real=True)
    coords_2d = [theta, phi]
    # ds^2 = dtheta^2 + sin^2(theta) dphi^2
    g_matrix_2d = sp.diag(1, sp.sin(theta)**2)
    sphere_metric = Metric(g_matrix_2d, coords_2d)

    print("--- æ¸¬åœ°ç·šæ–¹ç¨‹å¼ (ç¬¦è™Ÿ) ---")
    eqs = sphere_metric.get_geodesic_equations()
    for eq in eqs:
        sp.pprint(eq)
    print("\n")

    # --- æ•¸å€¼æ±‚è§£æ¸¬åœ°ç·š (BVP) ---
    # å®šç¾©èµ·é» A: åŒ—æ¥µé™„è¿‘ (theta=0.1, phi=0)
    # å®šç¾©çµ‚é» B: èµ¤é“ä¸ŠæŸé» (theta=pi/2, phi=pi/2)
    start = [0.1, 0] 
    end = [np.pi/2, np.pi/2]

    print(f"æ­£åœ¨è¨ˆç®—å¾ {start} åˆ° {end} çš„æ¸¬åœ°ç·š...")
    path = sphere_metric.solve_geodesic_bvp(start, end, num_points=50)

    # path[0] æ˜¯ theta é™£åˆ—, path[1] æ˜¯ phi é™£åˆ—
    thetas = path[0]
    phis = path[1]

    # --- è¦–è¦ºåŒ– (è½‰æ›å›ç›´è§’åæ¨™ç¹ªåœ–) ---
    X = np.sin(thetas) * np.cos(phis)
    Y = np.sin(thetas) * np.sin(phis)
    Z = np.cos(thetas)

    # ç•«å‡ºçƒé«”ç¶²æ ¼
    u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
    x_sphere = np.cos(u)*np.sin(v)
    y_sphere = np.sin(u)*np.sin(v)
    z_sphere = np.cos(v)

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_wireframe(x_sphere, y_sphere, z_sphere, color="gray", alpha=0.3)

    # ç•«å‡ºæ¸¬åœ°ç·š
    ax.plot(X, Y, Z, color='r', linewidth=2, label='Geodesic')
    ax.scatter([X[0]], [Y[0]], [Z[0]], color='g', s=50, label='Start')
    ax.scatter([X[-1]], [Y[-1]], [Z[-1]], color='b', s=50, label='End')

    ax.legend()
    plt.show()
